// Copyright 2023 QMK
// SPDX-License-Identifier: GPL-2.0-or-later
#include "quantum.h"
#include "raw_hid.h"
#include "via.h"
#include "print.h"

static char     img_data[512] = {0}; // Buffer stores the image data
static uint16_t data_count = 0;

#ifdef SWAP_HANDS_ENABLE

__attribute__ ((weak))
const keypos_t PROGMEM hand_swap_config[MATRIX_ROWS][MATRIX_COLS] =
    // The LAYOUT macro could work for this, but it was harder to figure out the
    // identity using it.

    // This is the identity layout.
/*
{
    { {0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0} },
    { {0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1} },
    { {0, 2}, {1, 2}, {2, 2}, {3, 2}, {4, 2}, {5, 2} },
    { {0, 3}, {1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3} },
    { {0, 4}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4} },

    { {0, 5}, {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5} },
    { {0, 6}, {1, 6}, {2, 6}, {3, 6}, {4, 6}, {5, 6} },
    { {0, 7}, {1, 7}, {2, 7}, {3, 7}, {4, 7}, {5, 7} },
    { {0, 8}, {1, 8}, {2, 8}, {3, 8}, {4, 8}, {5, 8} },
    { {0, 9}, {1, 9}, {2, 9}, {3, 9}, {4, 9}, {5, 9} },
};
*/

    // This is the mirror, q <-> p, w <-> o, etc...
{
 { {0, 5}, {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5} },
 { {0, 6}, {1, 6}, {2, 6}, {3, 6}, {4, 6}, {5, 6} },
 { {0, 7}, {1, 7}, {2, 7}, {3, 7}, {4, 7}, {5, 7} },
 { {0, 8}, {1, 8}, {2, 8}, {3, 8}, {4, 8}, {5, 8} },
 { {0, 9}, {1, 9}, {2, 9}, {3, 9}, {4, 9}, {5, 9} },

 { {0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0} },
 { {0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1} },
 { {0, 2}, {1, 2}, {2, 2}, {3, 2}, {4, 2}, {5, 2} },
 { {0, 3}, {1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3} },
 { {0, 4}, {1, 4}, {2, 4}, {3, 4}, {4, 4}, {5, 4} },
};

#    ifdef ENCODER_MAP_ENABLE
const uint8_t PROGMEM encoder_hand_swap_config[NUM_ENCODERS] = {1, 0};
#    endif

#endif

#ifdef OLED_ENABLE
oled_rotation_t oled_init_kb(oled_rotation_t rotation) {
    if (is_keyboard_master()) {
        // return OLED_ROTATION_270;
		return OLED_ROTATION_0;
    }
    return rotation;
}

// static void render_logo(void) {
    // static const char PROGMEM qmk_logo[] = {
// 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0x1F,0x3F,0x7F,0xFF,0xFF,0xFF,0xCF,0xCF,0xC3,0xC3,0xFF,0xFF,0xFF,0xFF,0x1F,0x1F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x1F,0x1F,0xFF,0xFF,0xFF,0xFF,0xC3,0xC3,0xCF,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x7F,0x7F,0x0F,0xFF,0x3F,0xBF,0xBF,0xFF,0xBF,0x3F,0xFF,0xFF,0x3F,0xFF,0x7F,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x1F,0x1F,0x1F,0x3C,0x3C,0x3C,0x38,0x38,0x39,0x73,0xF7,0xFF,0xFF,0xFF,0x03,0x03,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0xFF,0xFF,0xF8,0xFF,0xFC,0xFA,0xFB,0xFF,0xFF,0xFE,0xE4,0xDD,0xE0,0xFF,0xFE,0xF4,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xFC,0xFE,0xFE,0xFE,0xFE,0x0F,0x07,0x07,0x83,0xC3,0xE3,0xFB,0xFD,0xFF,0xE0,0xE0,0x80,0x87,0x8F,0x9F,0x9F,0x1F,0x1F,0x18,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x18,0x18,0x1C,0x9E,0x9F,0x8F,0x87,0x80,0xE0,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFF,0xFF,0xF9,0xF9,0xE1,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC4,0xC4,0xC4,0xDC,0xC8,0xDC,0xC4,0xC4,0xDC,0xC8,0xDC,0xC4,0xC4,0xC4,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE1,0xE1,0xF9,0xF9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF

    // };
    // oled_write_raw_P(qmk_logo, 512);
// }

void keyboard_post_init_kb(void) {
  // Customise these values to desired behaviour
  debug_enable=true;
  debug_matrix=false;
  debug_keyboard=false;
  debug_mouse=false;
}

void print_status_narrow(void) {
    oled_write_P(PSTR("\n\n"), false);
    switch (get_highest_layer(layer_state)) {
        case 0:
            oled_write_ln_P(PSTR("Qwrt"), false);
            break;
        case 1:
            oled_write_ln_P(PSTR("Clmk"), false);
            break;
        default:
            oled_write_P(PSTR("Mod\n"), false);
            break;
    }
    oled_write_P(PSTR("\n\n"), false);
    oled_write_ln_P(PSTR("LAYER"), false);
    switch (get_highest_layer(layer_state)) {
        case 0:
        case 1:
            oled_write_P(PSTR("Base\n"), false);
            break;
        case 2:
            oled_write_P(PSTR("Raise"), false);
            break;
        case 3:
            oled_write_P(PSTR("Lower"), false);
            break;
        default:
            oled_write_ln_P(PSTR("Undef"), false);
    }
    oled_write_P(PSTR("\n\n"), false);
    led_t led_usb_state = host_keyboard_led_state();
    oled_write_ln_P(PSTR("CPSLK"), led_usb_state.caps_lock);
}

bool oled_task_kb(void) {
    if (!oled_task_user()) {
        return false;
    }
    if (is_keyboard_master()) {
		// render_logo();
        // print_status_narrow();
    } else {
		// print_status_narrow();
        // render_logo();
    }
    return true;
}

#endif

#ifdef ENCODER_ENABLE
bool encoder_update_kb(uint8_t index, bool clockwise) {
    if (!encoder_update_user(index, clockwise)) {
        return false;
    }
    if (index == 0) {
        if (clockwise) {
            tap_code(KC_VOLU);
        } else {
            tap_code(KC_VOLD);
        }
    } else if (index == 1) {
        if (clockwise) {
            tap_code(KC_PGDN);
        } else {
            tap_code(KC_PGUP);
        }
    }
    return true;
}
#endif

// The via_command_kb() overrides raw_hid_receive() of 'via.c'
// Rmb to return true, if not, raw_hid_receive() will continue
bool via_command_kb(uint8_t *data, uint8_t length) { // Should I use this or via_custom_value_command_kb???
	dprint("*** New HID packet ***\n");
	// char temp[32] = {0};
	for (uint8_t i = 0; i<32; i++) {
		uprintf("%X ", data[i]);
		// temp[i] = data[i];
	}
	dprint("\n");
	uint8_t *command_id   = &(data[0]);
    // uint8_t *command_data = &(data[1]);

    switch (*command_id) {
		case 0xAA: { // 170: System time, Volume, GPU, CPU, RAM
			break;
			char buf1[32] = {0};
			// sprintf(buf1, "%d:%d", data[1], data[2]);
			oled_set_cursor(0,0);
			oled_write(buf1, false);
			// qp_drawtext(my_display, 10, 30, thintel, buf1);
			// sprintf(buf1, "Vol: %d%%", data[3]);
			oled_set_cursor(0,1);
			oled_write(buf1, false);
			// qp_drawtext(my_display, 10, 50, thintel, buf1);
			// sprintf(buf1, "CPU: %d. GPU: %d. RAM: %d", data[4], data[5], data[6]);
			// oled_set_cursor(0,2);
			// oled_write(buf1, false);
			// qp_drawtext(my_display, 10, 70, thintel, buf1);
			// dprint(buf1);
			break;
		}
		// case 0xAB: { // 171
			// char buf1[16] = {0};
			// sprintf(buf1, "0xAB: %d ", data[1]);
			// qp_drawtext(my_display, 10, 30, thintel, buf1);
			// print(buf1);
			// break;
		// }
		// case 0xAC: { // 172
			// char buf1[16] = {0};
			// uint8_t i = 0;
			// while (data[i] != 0x00) {
				// sprintf(buf1, "%d ", data[i]);
				// i++;
			// }
			// qp_drawtext(my_display, 10, 30, thintel, buf1);
			// print(buf1);
			// break;
		// }
		case 0xA5: { // Receive image via HID - Step1: HANDSHAKE
			oled_clear();
			raw_hid_send(data, length);
			data_count = 0; // Reset counter, ready for incoming image
			dprint("0xA5 -> Handshake done, ready to receive image data.\n");
			for (uint8_t i = 0; i<32; i++) {
				uprintf("%X-", data[i]);
			}
			dprint("\n");
			break;
		}
		case 0xA6: { // Receive image via HID - Step2: Receiving data
			dprint("0xA6 -> Data received: ");
			for (uint8_t i = 0; i < 24; i++) {
				img_data[data_count] = data[i+5];
				uprintf("data_count = %d - img_data = %X\n", data_count, img_data[data_count]);
				data_count++;
				if (data_count > 512) { // All packets are sent
					for (uint16_t i = 0; i < 512; i++) {
						uprintf("0x%02X,", img_data[i]);
					}
					oled_write_raw(img_data,512);
				}
			}
			dprint("\n");
			break;
		}
		default: { // The value ID is not my custom command
			return false; // Return to raw_hid_receive of via.c
			break;
		}
	}

	return true;
}
